// Содержимое файла src/standoff/enemies_counter.h

extern int abs_ScreenX;
extern int abs_ScreenY;
extern uint64_t il2cpp_base;

template <typename T>
T rpm(uint64_t addr);

int countEnemies() {
    uint64_t playermanager = rpm<uint64_t>(rpm<uint64_t>(rpm<uint64_t>(rpm<uint64_t>(il2cpp_base + 135070688) + 0x58) + 0xB8) + 0x0);
    if(!playermanager) return 0;

    uint64_t playersList = rpm<uint64_t>(playermanager + 0x28);
    uint64_t localPlayer = rpm<uint64_t>(playermanager + 0x70);

    if(!playersList || !localPlayer) return 0;

    int playersListSize = rpm<int>(playersList + 0x20);
    if(playersListSize <= 0 || playersListSize > 32) return 0;

    uint64_t localPhoton = rpm<uint64_t>(localPlayer + 0x158);
    uint64_t localProps = rpm<uint64_t>(localPhoton + 0x38);
    int localTeam = 0;
    if(localProps) {
        int propsSize = rpm<int>(localProps + 0x20);
        for(int j = 0; j < propsSize; j++) {
            uint64_t propsList = rpm<uint64_t>(localProps + 0x18);
            uint64_t propkey = rpm<uint64_t>(propsList + 0x28 + 0x18 * j);
            if(propkey) {
                char keyBuf[32] = {0};
                int keyLen = rpm<int>(propkey + 0x10);
                if(keyLen > 0 && keyLen < 20) {
                    for(int k = 0; k < keyLen; k++) {
                        keyBuf[k] = rpm<char>(propkey + 0x14 + k * 2);
                    }
                    if(strstr(keyBuf, "team")) {
                        uint64_t propval = rpm<uint64_t>(propsList + 0x30 + 0x18 * j);
                        localTeam = rpm<int>(propval + 0x10);
                        break;
                    }
                }
            }
        }
    }

    int enemyCount = 0;
    for(int i = 0; i < playersListSize; i++) {
        uint64_t player = rpm<uint64_t>(rpm<uint64_t>(playersList + 0x18) + 0x30 + 0x18 * i);
        if(!player) continue;

        uint64_t photon = rpm<uint64_t>(player + 0x158);
        uint64_t props = rpm<uint64_t>(photon + 0x38);

        int hp = 0;
        int playerTeam = 0;

        if(props) {
            int propsSize = rpm<int>(props + 0x20);
            for(int j = 0; j < propsSize; j++) {
                uint64_t propsList = rpm<uint64_t>(props + 0x18);
                uint64_t propkey = rpm<uint64_t>(propsList + 0x28 + 0x18 * j);
                if(propkey) {
                    char keyBuf[32] = {0};
                    int keyLen = rpm<int>(propkey + 0x10);
                    if(keyLen > 0 && keyLen < 20) {
                        for(int k = 0; k < keyLen; k++) {
                            keyBuf[k] = rpm<char>(propkey + 0x14 + k * 2);
                        }
                        uint64_t propval = rpm<uint64_t>(propsList + 0x30 + 0x18 * j);
                        if(strstr(keyBuf, "health")) {
                            hp = rpm<int>(propval + 0x10);
                        }
                        if(strstr(keyBuf, "team")) {
                            playerTeam = rpm<int>(propval + 0x10);
                        }
                    }
                }
            }
        }

        if(hp <= 0) continue;
        if(playerTeam == localTeam) continue;

        enemyCount++;
    }

    return enemyCount;
}

void renderEnemiesCounter() {
    if (!enemies_counter_enabled) return;

    int enemyCount = countEnemies();
    
    // Получаем текущий список для отрисовки
    ImDrawList* drawList = ImGui::GetForegroundDrawList();
    
    // Создаем строку с количеством противников
    char enemyCountStr[32];
    sprintf(enemyCountStr, "Enemies: %d", enemyCount);
    
    // Вычисляем размер текста
    ImVec2 textSize = ImGui::CalcTextSize(enemyCountStr);
    
    // Позиция по центру сверху
    float posX = (abs_ScreenX - textSize.x) / 2.0f;  // Центрируем по горизонтали
    float posY = 10.0f;  // Отступ от верха (в самом верху)
    
    ImVec2 textPos(posX, posY);
    
    // Рисуем черный фон за текстом
    ImVec2 padding(10.0f, 5.0f);  // Отступы вокруг текста
    ImVec2 bgMin(textPos.x - padding.x, textPos.y - padding.y);
    ImVec2 bgMax(textPos.x + textSize.x + padding.x, textPos.y + textSize.y + padding.y);
    
    drawList->AddRectFilled(bgMin, bgMax, IM_COL32(0, 0, 0, 255));  // Черный фон
    
    // Рисуем текст поверх фона
    drawList->AddText(textPos, IM_COL32(255, 255, 255, 255), enemyCountStr);  // Белый текст
}